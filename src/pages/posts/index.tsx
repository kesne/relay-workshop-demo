/**
 * Welcome to the Relay Workshop Demo! This is a little interactive demo that
 * I made to show how to actually use Relay in React applications.
 *
 * This file is a route, which can be viewed in your browser at http://localhost:3000/posts.
 *
 * Relay is already setup and available to React components. That setup is mostly in
 * the root-level configuration (i.e. babel + relay config), and within the `_app.tsx`
 * file, which wraps all pages. I wouldn't worry too much about that though, as the
 * setup is fairly simple, and mostly just wrapping components in a context provider.
 *
 * If you are interested in the actual low-level Relay environment, I'd recommend
 * reading the `src/relayEnvironment.ts` file, which is responsible for actually
 * setting up the global Relay environment.
 */

import React from "react";
import { graphql, useQuery } from "relay-hooks";
import { Center, Loader } from "@mantine/core";
import { PostsList } from "../../components/PostsList";
import { postsListPageQuery } from "./__generated__/postsListPageQuery.graphql";

export default function PostsListPage() {
  /**
   * This executes a GraphQL query, which is defined inside of the `graphql` tagged
   * template string.
   *
   * This hook returns a bag of properties, the ones we're using here are:
   * - `data`, which contains the actual response data,
   * - `isLoading`, which is `true` while this data is being fetched over the network.
   *
   * This hook also has one TypeScript generic argument. In this argument we provide the
   * generated TypeScript type for this GraphQL query. This is generated by running
   * `yarn relay` in the project, which runs the Relay Compiler. By passing the generic
   * here, we get full type safety for this GraphQL query! You can try to access
   * fields that haven't been queried, and you'll get a type error.
   *
   * This implementation uses lazy loading, where the query is fetched during the rendering
   * of the component. It's worth noting that this is not the ideal way to fetch data.
   * Ideally, we would start preloading data before we start rendering the page.
   * For more details on why this project does not leverage preloading, see the README.
   */
  const { data, isLoading } = useQuery<postsListPageQuery>(graphql`
    # Define a query, which is used to load data. The name of the query here
    # matches a pre-set Relay naming convention. The compiler will error if your
    # query names do not match the expected naming convention.
    query postsListPageQuery {
      # This query loads the "posts" field from the root Query type:
      posts {
        # Here we don't define any data dependencies ourself, we actually just
        # "spread" the data dependencies of another component. In this case, the
        # naming convention tells us we are "spreading" the data dependencies of
        # the "PostsList" component, for the "Post" type.
        # These are defined in the components themslves, inside of the "useFragment"
        # hook. Go check out the "PostsList/index.tsx" file to see how components
        # can define their own data requirements.
        ...PostsList_post
      }
    }
  `);

  /**
   * Relay performs what is known as "Data Masking" to the data that is resolved
   * through the hooks. This means that in this component, we only have access
   * to data that we have explicitly requested. Even though we have added the data
   * requirements of our child components in the query above, we cannot ourself
   * access them. This helps prevent bugs, and makes sure that you are always
   * defining the data that you actually need, and not implicitly depending on
   * the data requirements of the components you are composing.
   *
   * Try this out! Uncomment the line below, and look in the browser console to
   * see data masking is working. You'll see a bunch of internal Relay properties,
   * but you won't see any actual properties from the `PostsList_post` fragment.
   */
  // console.log(data?.posts[0]);

  if (isLoading || !data) {
    return (
      <Center>
        <Loader mt="xl" />
      </Center>
    );
  }

  return <PostsList posts={data.posts} />;
}
